<div class="container">
    <h1>Afficher les donn√©es venant du typeSricpt dans le template, double accolades le nom de la varibale/propri√©t√© remplac√© par sa valeur ou contenu de la propri√©t√©.</h1>
    <h4>Interpolation</h4>
    <p>La string interpolation est la m√©thode la plus simple pour afficher le contenu d'une variable dans le template. Il suffit de mettre le nom de la variable √† afficher entre doubles accolades dans le HTML. Angular remplace la variable entre doubles accolades par sa valeur </p>
    <h4>Objectif de l'app</h4>
    <p>L'objectif de l'application Snapface est de partager des images. Il nous faut donc un moyen d'afficher dynamiquement des images ! L'approche dans ce genre de cas sera souvent que le serveur renvoie l'URL de l'image √† afficher. Il nous faut donc un moyen de lier cette URL dynamique √† l'attribut  src  d'une balise <img> : attribute binding !</p>
    <h4>Afficher face Snap</h4>

    <div class="face-snap-card" [ngClass]="{ snapped: buttonText === 'Opps, unSnap!' }">
        <!-- <div class="face-snap-card" [ngClass]="{ snapped: faceSnap.snaps > 400 }"> -->
        <h2>{{ faceSnap.title | uppercase }}</h2>
        <h3>{{ faceSnap.description | titlecase }}</h3>
        <p>L√†, Angular associe les valeurs des propri√©t√©s TypeScript aux attributs de l'√©l√©ment HTML</p>
        <p *ngIf="faceSnap.location" style="color: red;">Photo prise √† {{ faceSnap.location | uppercase }}</p>
        <!-- <p *ngIf="faceSnap.location === 'Paris'" style="color: red;">Photo prise √† {{ faceSnap.location }}</p> -->
        <img [src]="faceSnap.imageUrl" [alt]="faceSnap.title"> 
        <p>Mis en ligne: {{ faceSnap.createDate | date: '√† HH:mm:ss, le d/MMMM/yyyy' }}</p>
        <h4>Snap ou non Snap!</h4>
        <p><button (click)="onSnap()"> {{ buttonText }}</button> <!--On utilise bien  (click)  et non  (onclick)  car on veut r√©agir √† l'√©v√©nement qui s'appelle "click" !-->
            <span [ngStyle]="{color: 'rgb(0, ' + faceSnap.snaps/2 + ', 0)'}">Emoji ü§û: {{ faceSnap.snaps }}</span> </p>
        <h4>Pipes Numbers</h4>
        <p>{{ 4346234.365 | number: '1.0-2' }}</p>
        <p>{{ 0.3665 | percent: '1.0-2' }}</p>
        <p>{{ 102.56 | currency: 'EUR' : 'code' }}</p> <!-- 102.56 | currency => 102,56 $US par d√©fault et currency: 'EUR' : 'code'  => 102,56 EUR-->

    </div>
    <p>√áa y est ! La fonctionnalit√© est termin√©e : vous avez r√©ussi √† r√©agir √† un √©v√©nement venant du template, et √† ex√©cuter un comportement conditionnel, tout en vous servant de la string interpolation pour afficher le r√©sultat et pour rendre dynamique le texte du bouton !</p>
    <p>Si l'utilisateur a d√©j√† "snapped" une image, le texte du bouton doit √™tre "Oops, un Snap!", et cliquer dessus doit "retirer" le snap (r√©duire les snaps de 1), auquel moment le bouton r√©affiche "Oh Snap!", et retrouve son comportement d'origine.</p>
    <h4>D√©claration des propri√©t√©s</h4>
    <div class="resume-card">
        On d√©clare les propri√©t√©s d'un component en haut de sa classe, et on les initialise dans la m√©thode  ngOnInit()
        La m√©thode  ngOnInit()  est appel√©e une fois par instance de component au moment de la cr√©ation de cette instance.
        La string interpolation avec les doubles accolades permet d'ins√©rer la valeur d'une propri√©t√© TypeScript dans le template.
        L'attribute binding permet de lier la valeur d'une propri√©t√© TypeScript √† un attribut HTML, en mettant l'attribut entre crochets  []  et en passant le nom de la propri√©t√©.
    </div>
    <h4>instance e component</h4>
    <div class="resume-card">
        Prenons quelques instants pour noter que chaque instance d'un component est totalement ind√©pendante. Pour le v√©rifier, ajoutez quelques instances suppl√©mentaires de FaceSnapComponent, et cliquez sur leurs boutons "Oh Snap!". Vous verrez que seul le nombre de snaps pour le component o√π vous cliquez augmente.
        Pour lier une m√©thode √† un √©v√©nement d'un √©l√©ment du template, mettez l'√©v√©nement entre parenth√®ses  ()  et passez la m√©thode en argument ; ex. : (click)="onClickButton()"
    </div>
    <h4>Importer avec @Input</h4>
    <div class="resume-card">
        <h4>Injection de propri√©t√©</h4>
        <div class="injection">
            Pour qu'une propri√©t√© puisse √™tre inject√©e depuis l'ext√©rieur d'un component, il faut lui ajouter le d√©corateur  @Input().
            Dans app.component.ts  ‚Äì le parent de FaceSnapComponent ‚Äì cr√©ez une propri√©t√© de type  FaceSnap  et initialisez-la dans  ngOnInit().
            N'oubliez pas d'impl√©menter  OnInit  pour pouvoir utiliser  ngOnInit()  dans AppComponent !
        </div>
        <h4>attribut binding</h4>
        <div>
            Utiliser l'attribute binding pour lier cet objet √† la propri√©t√© personnalis√©e  faceSnap  de FaceSnapComponent dans  app.component.html.
            @Input() cr√©e comme un attribut HTML auquel on peut lier une valeur, tout comme vous l'avez fait avec l'attribut  src  de l'√©l√©ment image. !
            N'h√©sitez pas √† cr√©er vos propres types, sous forme de classe par exemple, pour faciliter la manipulation de donn√©es dans votre application.
        </div>
      
        <h4>Propri√©t√© personnalis√©e</h4>
       <div>
        Une propri√©t√© personnalis√©e est rendue injectable depuis l'ext√©rieur gr√¢ce au d√©corateur  @Input()
        Une propri√©t√© en  @Input()  est utilisable comme n'importe quelle autre propri√©t√© : on peut en afficher les √©l√©ments, les modifier‚Ä¶ 
        On lie ensuite une valeur √† cette propri√©t√© depuis le component parent avec l'attribute binding, c'est-√†-dire le nom de la propri√©t√© entre crochets  []  en passant la valeur entre les guillemets ; ex. : faceSnap="mySnap"
       </div>
      
    </div>
    <br><br>
    <h2>Directive</h2>
    <div class="directiv-card">
        <h4>NgIf</h4>
        <div class="ngif">
            Une directive est une classe qui vient ajouter du comportement √† l'√©l√©ment sur lequel elle est pos√©e. L'ast√©risque au d√©but du nom  *ngIf nous montre qu'il s'agit d'une directive structurelle, qui viendra donc toucher √† la structure du document.
            *ngIf  permet donc de structurer vos components selon les conditions que vous choisissez. 
        </div>
        <br>
        <h4>propri√©t√© optionnelle</h4>
        <div class="attribut-optionel">
            Le TypeScript nous permet d'ajouter des propri√©t√©s optionnelles aux classes, aux objets, et m√™me des arguments optionnels aux m√©thodes. Je vous propose d'ajouter d√®s maintenant une propri√©t√© optionnelle √† la classe FaceSnap, qui sera la localisation de l'image. On pourrait imaginer que les utilisateurs puissent choisir d'ajouter ou non cette localisation. Pour ajouter cette propri√©t√© optionnelle, il suffit d'utiliser un point d'interrogation.
            Ajouter la directive  *ngIf  √† un √©l√©ment (qui peut aussi √™tre un component) dit √† Angular d'ajouter ou non cet √©l√©ment au DOM selon la condition que vous lui passez.
        </div>
        <h4>NgFor-01102022</h4>
        <div>
            Au lieu d'avoir trois variables de type FaceSnap  dans votre AppComponent, vous allez cr√©er une seule variable qui contiendra un tableau de type FaceSnap[] et modifier votre ngOnInit() pour le remplir.
            <br>
            la directive  *ngFor  fonctionne un peu comme une boucle  for...of  , c'est-√†-dire que, dans ce cas de figure, elle va it√©rer sur le tableau  faceSnaps  et vous exposer l'√©l√©ment correspondant √† chaque it√©ration sous l'alias  faceSnap
            vous associez ensuite l'√©l√©ment du tableau √† la propri√©t√©  faceSnap  du component.
            <h4>En R√©sum√©</h4>
            La directive  *ngFor  vous permet d'ins√©rer un √©l√©ment dans le DOM pour chaque √©l√©ment dans un tableau.
            La syntaxe  let element of array  vous donne acc√®s √† l'√©l√©ment de chaque it√©ration, vous permettant de l'injecter dans un component, par exemple.
        </div>
        <h4>NgStyle-01102022</h4>
        <div>La fonctionnalit√© que je vous propose d'ajouter maintenant est que plus un FaceSnap a de "snaps", plus le nombre de "snaps" sera color√© en vert. 
        Notre objectif ici est de changer la couleur de texte du nombre de snaps en fonction du nombre de snaps ‚Äì c'est parti !
        <h4>Ng-style</h4>
        Sous le capot, [ngStyle] ajoute une propri√©t√© en @Input  qui s'appelle ngStyle. La syntaxe entre crochets fonctionne comme pour la liaison par attribut (attribute binding), sauf qu'elle cr√©e la propri√©t√© en m√™me temps qu'elle y lie votre objet de styles. √áa fait partie des points forts de ce type de directive !
        <p>
            Bien s√ªr, avec cette impl√©mentation, √† partir de 255 snaps la couleur ne change plus ! Selon la sensibilit√© que vous souhaitez pour votre application, vous pouvez multiplier le nombre de snaps pour "acc√©l√©rer" le changement de couleur, ou le diviser pour ralentir le changement.
        </p>
        <h4>R√©sum√©</h4>
        <p>
            La directive [ngStyle] permet d'appliquer des styles qui d√©pendent de valeurs dynamiques, comme un texte qui, plus il y a de snaps, devient de plus en plus vert.
            La directive [ngStyle] prend comme argument un objet o√π les cl√©s correspondent aux styles CSS √† modifier, et les valeurs aux valeurs que doivent prendre ces styles.
        </p>
        <h4>NgClass-01102022</h4>
        <p>La meilleure fa√ßon de modifier plusieurs styles en m√™me temps est d'utiliser des classes CSS, surtout s'il s'agit d'un √©l√©ment avec plusieurs enfants. Dans ce chapitre, vous allez modifier plusieurs styles des √©l√©ments de vos cards quand un utilisateur clique sur "Oh Snap!" avec la directive[ngClass].</p>
        <h5>Objectif</h5>
        <p>L'objectif de ce chapitre est de faire ressortir visuellement les FaceSnaps que l'utilisateur a "snapped". On pourra imaginer une classe snapped  qui viendra s'ajouter √† la   div class="face-snap-card"  pour modifier quelques couleurs, par exemple. On ajoute cette classe dans  face-snap.component.scss.</p>
        <h5>impl√©mentation</h5>
        <p>[ngClass] prend un objet en argument, comme  [ngStyle], mais dont le fonctionnement est diff√©rent :
            les cl√©s sont les noms de classe CSS √† appliquer ;
            les valeurs sont les conditions qui doivent √™tre remplies pour que les classes correspondantes s'appliquent.</p>
            <h4>R√©sum√©</h4>
            <p>La directive [ngClass] permet d'ajouter dynamiquement des classes √† des √©l√©ments HTML.
                [ngClass] prend un objet en argument o√π les cl√©s sont des noms de classe CSS, et les valeurs sont les conditions selon lesquelles les classes doivent √™tre appliqu√©es.</p>
            <h3>R√©sum√© de la Parie 3</h3>
            <p>
                Vous avez d√©couvert les directives : des classes qui permettent d'ajouter des comportements √† des √©l√©ments HTML, ou m√™me √† des components.
                Vous avez impl√©ment√© des directives structurelles pour modifier la structure du document :
                1) *ngIf  pour ajouter un √©l√©ment ou non au DOM selon une condition donn√©e ;
                2) *ngFor  pour ajouter autant d'√©l√©ments au DOM qu'il y a d'√©l√©ments dans un tableau.
                Vous avez utilis√© des directives par attribut pour g√©rer dynamiquement les styles :
                3) [ngStyle]  pour param√©trer des styles selon des valeurs venant du TypeScript ;
                4) [ngClass]  pour ajouter et retirer des classes CSS selon une condition donn√©e. 
            </p>
        </div>
    </div>
    <div class="pipes">
            <h4>Pipes 0210202022 4√®me partie</h4>
            <p>Un pipe est appliqu√© dans le HTML et va formater la valeur qu'on lui passe selon le pipe utilis√© sans toucher √† la donn√©e sous-jacente. </p>
            <h3>Trois pipes pour modifier les class</h3>
            <p>Il existe trois pipes fournis par Angular pour modifier la casse :
                LowerCasePipe : on affiche le texte en minuscules
                UpperCasePipe : on affiche le texte en majuscules
                TitleCasePipe : on affiche le texte avec une majuscule au d√©but de chaque mot, avec le reste du mot en minuscules</p>
            <p>On applique un pipe √† une cha√Æne de caract√®res affich√©e avec la string interpolation. On rajoute le caract√®re pipe | puis le nom du pipe.</p>
            <h4>Note</h4>
            <p>Je tiens √† r√©p√©ter que les pipes ne changent rien √† la valeur des variables sous-jacentes. Les pipes existent uniquement pour modifier le formatage affich√© d'une donn√©e : on ne peut pas les utiliser ailleurs que dans le template, et il est fortement d√©conseill√© de les utiliser ailleurs que dans une string interpolation.</p>
            <h4>Resum√© Pipes 1</h4>
            <p>Un pipe permet de formater l'affichage d'une donn√©e sans modifier la donn√©e sous-jacente.
            Angular fournit trois pipes pour modifier la casse affich√©e d'une cha√Æne de caract√®res : UpperCasePipe, LowerCasePipe, et TitleCasePipe pour les majuscules, les minuscules et le m√©lange type "titre".</p>
            <h3>Formatez les dates</h3>
            <p>Pour configurer un pipe, on ajoute deux-points  :  puis g√©n√©ralement une cha√Æne de caract√®res qui d√©finit la configuration.</p>
            <p>Pour consulter toutes les possibilit√©s de configuration personnalis√©e, ainsi que la liste compl√®te de formats pr√©d√©finis, consultez <a href="https://angular.io/api/common/DatePipe">la documentation DatePipe</a>.</p>
            <h4>Changez la locale par d√©faut</h4>
            <p>Pour changer la locale de votre application en fran√ßais, il faudra ajouter quelques lignes dans votre fichier</p>
            <h3>Resum√© 2 Date pipe</h3>
            <p>DatePipe permet de formater les dates, et sans configuration fournit un formatage par d√©faut.
            DatePipe fournit des configurations pr√©d√©finies avec des noms comme  short,  longDate  ou  mediumTime
            DatePipe permet √©galement de personnaliser totalement le format d'affichage des dates avec des cha√Ænes de caract√®res qui encodent le format souhait√©, par exemple  '√† HH:mm, le d MMMM yyyy'</p>
            <h3>Pipes Chiffre 02102022</h3>
            <h5>le formatage des nombres selon les r√®gles de locale de l'application</h5>
            <p>DecimalPipe ‚Äì facilite l'affichage de nombres avec des chiffres apr√®s la virgule (qui met une virgule plut√¥t qu'un point, par exemple).
            PercentPipe ‚Äì formate les chiffres en pourcentage.
            CurrencyPipe ‚Äì permet d'afficher des nombres sous forme de monnaie tr√®s facilement.</p>
            <p>Sachez qu'il existe d'autres pipes qui seront importants dans la suite de votre apprentissage Angular ‚Äì notamment le pipe async pour les Observables ‚Äì que vous ne verrez pas dans ce cours d'introduction. Pour plus d'informations, vous pouvez vous r√©f√©rer √† <a href="https://angular.io/api/common#pipes">la documentation Angular</a>.</p>
            <p>J'ai choisi un nombre √† 8 chiffres avant la virgule et 2 chiffres apr√®s, pour vous montrer les diff√©rences de format selon les diff√©rents pipes. </p>
            <h4>Arrondire</h4>
            <p>On peut aussi demander √† DecimalPipe d'arrondir pour l'affichage, par exemple √† l'entier le plus proche :entre accolades 4346234.36 | number: '1.0-0'= La configuration signifie :
            au moins un chiffre pour les entiers ;
            minimum 0 chiffres apr√®s la virgule ‚Äì maximum 0 chiffres (Angular arrondira donc √† l'entier le plus proche).
            </p>
            <p>On peut aussi sp√©cifier d'arrondir √† un chiffre apr√®s la virgule en sp√©cifiant un chiffre maximum apr√®s la virgule : entre accolades 4346234.36 | number: '1.0-1' </p>
            <h4>Note</h4>
            <p>Plus besoin de se prendre la t√™te avec la fonction  Math.round()  ! Angular peut afficher les nombres arrondis sans toucher √† la donn√©e sous-jacente.</p>
            <h3>Percent Pipe</h3>
            <p>Pour transformer des nombres entre 0 et 1 en pourcentage (ex. : 0.4 = 40 %), il suffit d'utiliser PercentPipe : entre accolades 0.336 | percent, arrondi par d√©faut, </p>
            <p>PercentPipe arrondit par d√©faut les pourcentages √† l'entier le plus proche. Vous pouvez cependant le configurer de la m√™me mani√®re que DecimalPipe :  entre accolades 0.336 | percent: '1.0-1' = En pourcentage avec un chiffre apr√®s la virgule </p>
            <h3>Currency Pipe</h3>
            <p>Quand les nombres dans votre application correspondent √† des montants d'argent, CurrencyPipe facilite leur affichage. Si vous utilisez l'affichage par d√©faut : entre accolades: 344.36 | currency => En dollars</p>
            <p>Angular pr√©sume par d√©faut que vous parlez de dollars, et donc affiche votre montant en dollars selon les r√®gles de la locale de l'application.
            Vous pouvez configurer la monnaie √† afficher : entre accolades 344.36 | currency: 'EUR' => En euros, ‚Ç¨</p>
            <p>Vous pouvez passer un deuxi√®me argument qui permet d'afficher le code de la monnaie plut√¥t que son symbole. Pour passer un deuxi√®me argument √† un pipe, on remet un deux-points  :  et on passe le deuxi√®me argument : entre accolades 344.36 | currency: 'EUR' : 'code' => En euros avec le code EUR</p>
            <h4>R√©sum√© Pipes Chiffres</h4>
            <ul>
                <li>DecimalPipe (mot-cl√©  number ) vous permet d'afficher un nombre selon les r√®gles de la locale de l'application.</li>
                <li>PercentPipe affiche un nombre entre 0 et 1 sous forme de pourcentage, arrondi par d√©faut √† l'entier le plus proche.</li>
                <li>DecimalPipe et PercentPipe acceptent un argument de configuration sous la forme 'chiffresMinAvantVirgule.chiffresMinApr√®sVirgule-chiffresMaxApr√®sVirgule' ex. :  '1.0-1'</li>
                <li>CurrencyPipe facilite l'affichage des montants d'argent, et accepte plusieurs arguments de configuration s√©par√©s par des deux-points :</li>
            </ul>
            <h3>R√©sum√© de la 4√®me Partie</h3>
            <ul>
                <li>Vous avez d√©couvert les pipes ‚Äì des outils pour g√©rer le format d'affichage d'une donn√©e sans modifier la donn√©e elle-m√™me.</li>
                <li>Vous avez chang√© la casse de vos cha√Ænes de caract√®res avec UpperCasePipe, LowerCasePipe et TitleCasePipe.</li>
                <li>Vous avez modifi√© l'affichage de la date de cr√©ation des FaceSnaps avec DatePipe, et vous avez vu les diff√©rentes mani√®res de personnaliser l'affichage des dates en passant un argument de configuration √† DatePipe.</li>
                <li>Vous avez manipul√© le format d'affichage des nombres avec DecimalPipe, PercentPipe et CurrencyPipe.</li>
            </ul>
    </div>
    <div class="partie5">
        <h2>Partie 5</h2>
        <div class="ch1">
            <h2>chapitre 1</h2>
            <h3>components</h3>
            <p>Dans une application compl√®te Angular, vous aurez des dizaines, voire des centaines de components diff√©rents. Ces components auront tr√®s souvent besoin d'acc√©der aux m√™mes donn√©es. Il y aura des interactions courantes avec ces donn√©es, comme l'√©criture, la modification et la suppression. L'application peut √©galement avoir besoin d'interagir avec un serveur concernant ces donn√©es, pour la lecture et l'enregistrement.</p>
            <h3>Services</h3>
            <p>Pour mieux organiser votre code, pour √©viter de r√©p√©ter des blocs et pour toujours avoir des donn√©es √† jour partout dans l'application, ce serait int√©ressant de pouvoir regrouper les donn√©es et leurs m√©thodes ensemble, de les centraliser. En Angular, cette centralisation se fait dans des services.</p>
            <h4>createDate face-snap-list: ng g c face-snap-list</h4>
            <p>Pour l'instant, AppComponent s'occupe de g√©n√©rer les FaceSnapComponents. Mais ce n'est pas un bon choix, surtout si vous voulez cr√©er une structure plus complexe par la suite. Vous allez cr√©er un nouveau component, FaceSnapListComponent, qui sera le parent de tous vos FaceSnapComponents.</p>
            <p>Ce nouveau component sera le parent des FaceSnapComponent : il a donc besoin du tableau qui se trouve actuellement dans AppComponent. Il faut aussi lui transplanter le template d'AppComponent.</p>
            <ul>
                <li>la logique qui g√®re la liste des FaceSnaps se trouve maintenant dans un component pr√©vu pour;</li>
                <li>et AppComponent ne contient que ce qu'il faut pour afficher les √©l√©ments principaux de l'application.</li>
            </ul>
            <h4>Note</h4>
            <p>Dans une application Angular, AppComponent ne sert g√©n√©ralement qu'aux √©l√©ments structuraux principaux. Tout ce qui est plus "sp√©cialis√©" va dans un component √† part.</p>
            <h4>Ajouter un header</h4>
            <p>Ajoutez tout de suite un nouvel √©l√©ment principal, HeaderComponent : ng g c header</p>
            <h4>Ajouter header dans app.component.html</h4>
            <p>Pour afficher le header au-dessus de la liste de FaceSnap, il suffit de l'ajouter dans le template de AppComponent.</p>
            <h3>Cr√©er un service pour g√©rer les FaceSnaps</h3>
            <p>Tout d'abord, une petite mise en garde sur les services : dans des applications plus complexes (la grande sp√©cialit√© d'Angular), la gestion des donn√©es est un sujet beaucoup plus vaste. Ce que vous ferez dans ce cours sera donc simplifi√© par rapport √† ce que vous rencontrerez par la suite. 
            Mais ne vous inqui√©tez pas ! Les techniques plus avanc√©es sont une extension de ce que vous apprendrez dans ce cours.</p>
            <p>Vous allez maintenant cr√©er un service qui va centraliser toutes les interactions avec les FaceSnaps, afin que tous les √©ventuels components de votre application d√©pendent des m√™mes donn√©es.</p>
            <h4>Cr√©er ce service manuellement</h4>
            <p>Dans le dossier  app, cr√©ez un dossier  services  et dedans un fichier  face-snaps.service.ts.
            Un service est une classe, et la fa√ßon la plus simple de d√©clarer une classe comme √©tant un service est d'utiliser le d√©corateur  @Injectable()  qui s'importe depuis  @angular/core  :</p>
            <h4>Note</h4>
            <p>L'objet de configuration qui sp√©cifie  providedIn: 'root'  dit √† Angular d'enregistrer ce service √† la racine de l'application. Ce sera tr√®s souvent le cas pour vos services, car √ßa permet de s'assurer de n'avoir qu'une seule instance du service, partag√©e par tous les partis int√©ress√©s.</p>
            <p>Le premier √©l√©ment que vous allez d√©porter dans votre service est le tableau des FaceSnaps. Il est important de savoir qu'un service n'a pas de m√©thode ngOnInit(), car les services ne sont pas instanci√©s de la m√™me mani√®re que les components. Il faudra donc d√©clarer et initialiser le tableau dans la m√™me expression.</p>
            <h3>Injection du Service</h3>
            <p>Pour pouvoir utiliser un service dans un component, il faut utiliser <span style="color: blue;">le syst√®me d'injection de d√©pendances (dependency injection ou DI) </span> que vous fournit Angular. C'est tr√®s simple : <span style="color: red;">vous passez un argument du type du service au constructor du component</span>, et Angular vous mettra √† disposition la bonne instance du service. </p>
            <h4>Rappel</h4>
            <p>Pour rappel, ajouter un modificateur d'acc√®s comme  public  ou  private  √† un argument du  constructor  cr√©e une propri√©t√© avec ce nom-l√† dans la classe. Vous aurez donc acc√®s au service via la propri√©t√©  faceSnapsService.</p>
            <h4>Note</h4>
            <p>On pr√©f√®re g√©n√©ralement  private  pour les injections de service, car √ßa emp√™che le template du component d'y acc√©der directement. Donner au template acc√®s aux injections serait un anti-pattern Angular ‚Äì autrement dit, une approche plus que d√©conseill√©e, souvent pour des raisons qui ne sont pas flagrantes au premier abord.</p>
            <h4>Intialiser la propri√©t√© face-snap</h4>
            <p>Maintenant que vous avez acc√®s au service, vous pouvez modifier l'initialisation de la propri√©t√©  faceSnaps du component pour y attribuer le tableau du service.</p>
            <h4>Partager les donn√©es</h4>
            <p>Et votre application refonctionne, sauf que maintenant elle utilise les donn√©es du service ! √áa veut dire qu'√† l'avenir, vous pourriez r√©cup√©rer ces donn√©es depuis un serveur, par exemple. Pour cela, il faut de la logique, des m√©thodes, donc dans le prochain chapitre, vous verrez comment partager des m√©thodes dans votre service.</p>
            <h4>R√©sum√© du CH1</h4>
            <ul>
                <li>Les services permettent de centraliser les donn√©es et la logique pour les diff√©rents domaines de votre application.</li>
                <li>Cr√©er un service est aussi simple qu'ajouter le d√©corateur  @Injectable()  √† une classe.</li>
                <li>Pour injecter un service dans un component, ajoutez un argument au constructor du component qui a le type du service, par exemple <span style="color: rgb(119, 0, 255);">userService: UserService</span></li>
            </ul>
        </div>
        <div>
            <h2>chapitre 2</h2>
            <h3>introduction</h3>
            <p>Dans le chapitre pr√©c√©dent, vous avez cr√©√© un service qui contient tous vos FaceSnaps, et que vous utilisez dans FaceSnapListComponent.</p>
            <p>Cependant, dans une application totalement dynamique, on peut imaginer que ces FaceSnaps viendraient d'un serveur, ou d'une autre partie de l'application, et qu'il faudrait appeler une m√©thode pour les r√©cup√©rer. D'ailleurs, toute modification d'un FaceSnap entra√Ænerait √©galement un appel au serveur.</p>
            <p>Il faudra donc centraliser toutes les interactions avec les FaceSnaps dans FaceSnapsService, et c'est exactement ce que vous allez faire maintenant !</p>
            <h4>Cr√©er une m√©thode renvoie la liste de facesnaps</h4>
            <p>La premi√®re m√©thode que vous allez cr√©er est  getAllFaceSnaps(). Cette m√©thode retournera, comme son nom l'indique, tous les FaceSnaps contenus dans le service.</p>
            <p>M√™me si le comportement n'est pas modifi√© pour l'instant, cette structure vous permettrait √† terme de changer l'impl√©mentation de  getAllFaceSnaps()  sans casser le reste de l'application.Ce genre d'architecture modulaire est l'un des gros points forts d'Angular.</p>
            <h3>Snap ! Ajouter le nombre dans la base de donn√©es</h3>
            <p>Maintenant pour quelque chose d'un peu plus complexe : le snap ! Pour l'instant, tout se passe √† l'int√©rieur de FaceSnapComponent. Personne √† l'ext√©rieur du component ne sait que quelque chose a chang√©. Une vraie impl√©mentation de cette fonctionnalit√© ferait certainement un appel au backend pour augmenter le nombre de  snaps  dans la base de donn√©es, donc, comme pour toutes les interactions, il faut la faire passer par le service.</p>
            <h4>Cr√©er m√©thode pour snap ! Avant tout un id pour le FaceSnap</h4>
            <p>Pour l'instant, vous n'avez aucun moyen d'identifier un FaceSnap directement. Ajoutez d√®s maintenant une propri√©t√© obligatoire id de type number √† votre mod√®le FaceSnap</p>
            <p>Et ajoutez un  id  diff√©rent √† chacun des FaceSnaps dans votre service. Cet identifiant unique va vous permettre de snap un FaceSnap par son identifiant !</p>
            <p>Impl√©menteriez une m√©thode pour snap !</p>
            <ul>
                Cette m√©thode : 
                <li>cherche un FaceSnap par son id dans le tableau faceSnaps avec la fonction find();</li>
                <li>si le FaceSnap existe, on lui incr√©mente ses  snaps;</li>
                <li>sinon, on  throw  une erreur.</li>
            </ul>
            <p>Pour tester cette m√©thode, il faudra injecter FaceSnapsService dans FaceSnapComponent. Vous vous souvenez comment faire ?</p>
            <p>Voici ma proposition : on cr√©e une m√©thode  getFaceSnapById()  qui s'occupe de r√©cup√©rer le FaceSnap et de  throw  une erreur si on ne le trouve pas. Cela risque d'√™tre une fonctionnalit√© tr√®s utile √† plein d'endroits. On a deux options ensuite</p>
            <ul>
                <li>cr√©er deux m√©thodes : une pour snap, une pour unsnap;</li>
                <li>cr√©er une seule m√©thode √† laquelle on passe un argument qui dit s'il s'agit d'un snap ou d'un unsnap. => les literal types.</li>
            </ul>
            <h4>Analyser le code</h4>
            <p>Cette m√©thode getFaceSnapById() retourne un FaceSnap si elle le trouve (d'o√π son type de retour), et  throw  une erreur sinon.</p>
            <p>Maintenant la partie fun : vous allez modifier l'empreinte de snapFaceSnapById() pour qu'elle accepte un deuxi√®me argument qui permettra de choisir le snapType ‚Äì un snap, ou un unsnap.</p>
            <p>Cette m√©thode utilise  getFaceSnapById() pour r√©cup√©rer le FaceSnap, et si le deuxi√®me argument est  'snap', rajoute un snap; sinon, elle enl√®ve un snap.</p>
            <p>Cependant, on pourrait passer n'importe quelle cha√Æne de caract√®res √† cette m√©thode. Afin de limiter les possibilit√©s √† des options s√©mantiques, on peut remplacer le type  string  par un literal type.</p>
            <p>Ainsi, vous ne pourrez passer que 'snap' ou 'unsnap' comme deuxi√®me argument. Non seulement votre IDE vous pr√©viendra si vous essayez de passer autre chose, mais l'autocompl√©tion et la documentation automatique faciliteront l'utilisation de cette m√©thode.</p>
            <h4>R√©sum√© ch2</h4>
            <ul>
                <li>Centraliser les interactions dans un service sous forme de m√©thodes cr√©e une structure plus modulaire, qui facilite la maintenance et les √©volutions de votre application.</li>
                <li>Comme dans toute base de code, refactorisez pour √©viter de r√©p√©ter des blocs de code (le principe DRY : Don't Repeat Yourself).</li>
                <li>Les literal types permettent de cr√©er rapidement des types personnalis√©s, souvent utilis√©s pour limiter les choix pour un argument de m√©thode, par exemple : fileType: 'image' | 'video'</li>
            </ul>
            <h4>Literal Types</h4>
            <p>Cr√©er des types "limit√©s" comme √ßa, sous forme de literal types, ce n'est pas limit√© aux cha√Ænes de caract√®res ! Pour plus d'informations sur les literal types, n'h√©sitez pas √† plonger <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types">dans la documentation TypeScript</a>.</p>
        </div>
        <div>
            <h2>Chapitre 3 : Passez en SPA avec le routing</h2>
            <h4>SPA</h4>
            <p>Les Single Page Applications (ou SPA) sont de plus en plus courantes dans le monde du d√©veloppement web moderne. Elles permettent une performance sans √©gale en enlevant le besoin d'une application de demander, recevoir, puis afficher une nouvelle page HTML √† chaque changement d'URL. Angular vous permet avec le routing de cr√©er ce genre d'application ‚Äì √† chaque URL correspondra un component, et Angular remplacera le component actif sans √©mettre de requ√™te au serveur.</p>
            <p>Dans l'application Snapface, vous allez cr√©er une landing page afin de d√©couvrir le fonctionnement du routing ; puis, dans les prochains chapitres, vous ajouterez une autre route et d'autres fonctionnalit√©s de routing pour cr√©er une application plus compl√®te !</p>
            <h4>un module de routing</h4>
            <p>D'abord, vous allez ajouter un module de routing √† votre application. Dans le dossier  app, cr√©ez un fichier  app-routing.module.ts. Commencez par y d√©clarer une classe avec le d√©corateur @NgModule() :</p>
            <p>Au-dessus de la d√©claration de classe, vous allez initialiser une constante appel√©e  routes, de type  Routes  (import√© depuis  @angular/router) et qui contiendra un tableau.</p>
            <h4>Cr√©er une route facesnaps</h4>
            <p>Ce tableau va lier les routes de votre application (les diff√©rentes URL) aux components correspondants. Cr√©ez d√®s maintenant une premi√®re route  facesnaps qui affichera le component FaceSnapListComponent.</p>
            <p>const routes: Routes = [
                entre accolades path: 'facesnaps', component: FaceSnapListComponent 
              ];</p>
            <p>Pour enregistrer ces routes dans votre application, il faut les passer au routeur en passant un objet de configuration au d√©corateur @NgModule()  de AppRoutingModule :</p>
            <p>@NgModule( entre accolades: 
                imports: [
                  RouterModule.forRoot(routes)
                ],
                exports: [
                  RouterModule
                ]
              )</p>
              <p>RouterModule est aussi import√© depuis @angular/router.</p>
              <h4>Ajouter cette route dans appModule</h4>
              <p>Ici, vous dites √† Angular que les routes de ce fichier seront les routes √† la racine de votre application, et vous r√©exportez le routeur configur√©. Pour l'utiliser, il faut ajouter votre module de routing aux imports de AppModule, le module principal de votre application :</p>
              <p>@NgModule(entre accolades
                // ...
                imports: [
                  BrowserModule,
                  AppRoutingModule
                ],
                // ...
              )
              export class AppModule </p>
              <h4>Afficher la route</h4>
              <p>Il ne reste plus qu'√† dire √† Angular o√π il faut afficher le component dict√© par la route. Dans le template d'AppComponent, remplacez la balise entres les chevilles app-face-snap-list par une balise  router-outlet </p>
              <p>Comme √ßa, ce sera le routeur qui d√©cidera quel component doit √™tre affich√©, et AppComponent qui d√©cidera √† quel niveau ce component sera ajout√©. Dans ce cas, on a d√©cid√© que le AppHeader restera pr√©sent peu importe la route active, ce qui est plut√¥t r√©aliste : on pourrait m√™me envisager d'y placer un menu de navigation pour l'application.</p>
              <h4>Affiche le componenet</h4>
              <p>√Ä votre avis, pourquoi rien ne s'affiche ?
                Eh bien, c'est parce que vous n'avez pas sp√©cifi√© de component pour la route "vide" ! Cependant, si vous allez √† http://localhost:4200/facesnaps, vous retrouverez l'affichage pr√©c√©dent.</p>
                <h4>Landing Page</h4>
                <p>Si vous changez de route via la barre d'adresse de votre navigateur, une nouvelle requ√™te est envoy√©e au serveur de d√©veloppement, et l'application est totalement recharg√©e.
                <span style="color: blue;">Le but maintenant sera de cr√©er une landing page</span> pour la route "vide", qui permette d'acc√©der √† la route facesnaps.</p>
                <h4>Cr√©er Landing Page</h4>
                <ul>
                    Je vais commencer par vous pr√©senter l'objectif de cette partie du chapitre, pour que vous puissiez essayer de tout faire vous-m√™me.
                    <li>
                        <ul>
                            Cr√©er un component nomm√© LandingPageComponent :
                            <li>ce component peut √™tre aussi simple ou complexe que vous le souhaitez ! </li>
                        </ul>
                    </li>
                    <li>L'associer √† la route vide dans votre routing (indice : le path d'une route vide est le string vide).</li>
                </ul>
        </div>
        <div>
            <h2>Chapitre 4 : </h2>
        </div>
    </div>
</div>



